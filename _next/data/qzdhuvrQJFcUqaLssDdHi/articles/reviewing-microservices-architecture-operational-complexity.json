{"pageProps":{"data":{"title":"Reviewing the Microservices Architecture with Spring","date":"2022-05-02","desciption":"Taking Notes while trying to understand how to build and operationalize microservice-based applications","tags":"Backend, Spring, Java","thumbnail":"/img/some-thumbnail.png","content":"\n### Spring Cloud\n\n#### Spring Cloud Config\n\n- It handles the management of the application configuration data through a centralized service\n\n- This ensures that no matter how many microservice instances you bring up, they will always have the same configuration.\n\n- It provides server-side and client-side support for externalized configuration in a distributed system.\n\n#### Spring Cloud Service Discovery\n\n- A service registry is useful because it enables client-side load-balancing and decouples service providers from consumers without the need for DNS.\n\n- You can abstract away the physical location (IP and/or server name) of where your servers are deployed from the clients consuming the service.\n\n- It also handles the registration and deregistration of service instances as these are started and shut down.\n\n  - **Service Registration** - How a service registers with the service discovery agent\n\n  - **Client lookup of service address** - How a service client looks up service information\n\n  - **Information sharing** - How nodes share service information\n\n  - **Health monitoring** - How services communicate their health back to the service discovery agent\n\n#### Spring Cloud LoadBalancer and Resilience4j\n\n- Spring Cloud LoadBalancer library - It allows us to create applications that communicate with other applications in a load-balanced fashion. Using any algorithm we want, we can easily implement load balancing when making remote service calls\n\n- Resilience4j - It is a fault tolerance library which offers the following patterns for increasing fault tolerance due to network problems or failure of any of our multiple services\n\n  - **Circuit breaker** - Stops making requests when an invoked service is failing\n\n  - **Retry** - Retries service when it temporarily fails\n\n  - **Bulkhead** - Limits the number of outgoing concurrent service requests to avoid overload\n\n  - **Rate limit** - Limits the number of calls that a service receives at a time\n\n  - **Fallback** - Sets alternative paths for failing requests\n\n#### Spring Cloud Gateway\n\n- Mapping the routes for all the services in your application to a single URL\n\n- Building filters that can inspect and act on the requests and responses coming through the gateway. These filters allow us to inject policy enforcement points in our code and to perform a wide number of actions on all of our service calls in a consistent fashion. In other words, these filters allow us to modify the incoming and outgoing HTTP requests and responses.\n\n- Building predicates, which are objects that allow us to check if the requests fulfill a set of given conditions before executing or processing a requests\n\n- It is a reverse proxy. A reverse proxy is an intermediate server that sits between the client trying to reach a resource and the resource itself. The client has no idea it's even communicating with a server. The reverse proxy takes care of capturing the client's request andthen calls the remote resource on the client's behalf. Spring Cloud Gateway takes a microservice call from a client and forwards it to the upstream.\n\n- It integrates with Netflix's Eureka Server and can automatically map services registered with Eureka to a route.\n\n  - **Static routing** - A service gateway places all service calls behind a single URL and API route. This simplifies development as we only have to know about one service endpoint for all of our services.\n\n  - **Dynamic routing** - A service gateway can inspect incoming service requests and, based on the data from the incoming service, perform intelligent routing for the service caller.\n\n  - **Authentication and Authorization** - Because all service calls route through a service gateway, the service gateway is a natural place to check whether the callers of a service have authenticated themselves.\n\n  - **Metric collection and logging** - A service gateway can be used to collect metrics and log information as a service call passes through it.\n"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h3: \"h3\",\n    h4: \"h4\",\n    ul: \"ul\",\n    li: \"li\",\n    p: \"p\",\n    strong: \"strong\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h3, {\n      children: \"Spring Cloud\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Spring Cloud Config\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"It handles the management of the application configuration data through a centralized service\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"This ensures that no matter how many microservice instances you bring up, they will always have the same configuration.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"It provides server-side and client-side support for externalized configuration in a distributed system.\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Spring Cloud Service Discovery\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"A service registry is useful because it enables client-side load-balancing and decouples service providers from consumers without the need for DNS.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"You can abstract away the physical location (IP and/or server name) of where your servers are deployed from the clients consuming the service.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"It also handles the registration and deregistration of service instances as these are started and shut down.\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Service Registration\"\n              }), \" - How a service registers with the service discovery agent\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Client lookup of service address\"\n              }), \" - How a service client looks up service information\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Information sharing\"\n              }), \" - How nodes share service information\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Health monitoring\"\n              }), \" - How services communicate their health back to the service discovery agent\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Spring Cloud LoadBalancer and Resilience4j\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Spring Cloud LoadBalancer library - It allows us to create applications that communicate with other applications in a load-balanced fashion. Using any algorithm we want, we can easily implement load balancing when making remote service calls\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Resilience4j - It is a fault tolerance library which offers the following patterns for increasing fault tolerance due to network problems or failure of any of our multiple services\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Circuit breaker\"\n              }), \" - Stops making requests when an invoked service is failing\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Retry\"\n              }), \" - Retries service when it temporarily fails\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Bulkhead\"\n              }), \" - Limits the number of outgoing concurrent service requests to avoid overload\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Rate limit\"\n              }), \" - Limits the number of calls that a service receives at a time\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Fallback\"\n              }), \" - Sets alternative paths for failing requests\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Spring Cloud Gateway\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Mapping the routes for all the services in your application to a single URL\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Building filters that can inspect and act on the requests and responses coming through the gateway. These filters allow us to inject policy enforcement points in our code and to perform a wide number of actions on all of our service calls in a consistent fashion. In other words, these filters allow us to modify the incoming and outgoing HTTP requests and responses.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Building predicates, which are objects that allow us to check if the requests fulfill a set of given conditions before executing or processing a requests\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"It is a reverse proxy. A reverse proxy is an intermediate server that sits between the client trying to reach a resource and the resource itself. The client has no idea it's even communicating with a server. The reverse proxy takes care of capturing the client's request andthen calls the remote resource on the client's behalf. Spring Cloud Gateway takes a microservice call from a client and forwards it to the upstream.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"It integrates with Netflix's Eureka Server and can automatically map services registered with Eureka to a route.\"\n        }), \"\\n\", _jsxs(_components.ul, {\n          children: [\"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Static routing\"\n              }), \" - A service gateway places all service calls behind a single URL and API route. This simplifies development as we only have to know about one service endpoint for all of our services.\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Dynamic routing\"\n              }), \" - A service gateway can inspect incoming service requests and, based on the data from the incoming service, perform intelligent routing for the service caller.\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Authentication and Authorization\"\n              }), \" - Because all service calls route through a service gateway, the service gateway is a natural place to check whether the callers of a service have authenticated themselves.\"]\n            }), \"\\n\"]\n          }), \"\\n\", _jsxs(_components.li, {\n            children: [\"\\n\", _jsxs(_components.p, {\n              children: [_jsx(_components.strong, {\n                children: \"Metric collection and logging\"\n              }), \" - A service gateway can be used to collect metrics and log information as a service call passes through it.\"]\n            }), \"\\n\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\"]\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}
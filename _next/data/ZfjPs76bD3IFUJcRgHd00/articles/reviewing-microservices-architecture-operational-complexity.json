{"pageProps":{"data":{"title":"Reviewing the Microservices Architecture with Spring","date":"2020-05-02","desciption":"Taking Notes while trying to understand how to build and operationalize microservice-based applications","tags":"Backend, Spring, Java","thumbnail":"/img/some-thumbnail.png","content":"\n# Spring Cloud\n\n## Spring Cloud Config\n\n#### It handles the management of the application configuration data through a centralized service\n\n#### This ensures that no matter how many microservice instances you bring up, they will always have the same configuration.\n\n## Spring Cloud Service Discovery\n\n#### You can abstract away the physical location (IP and/or server name) of where your servers are deployed from the clients consuming the service.\n\n#### It also handles the registration and deregistration of service instances as these are started and shut down.\n\n- Service Registration - How a service registers with the service discovery agent\n\n- Client lookup of service address - How a service client looks up service information\n\n- Information sharing - How nodes share service information\n\n- Health monitoring - How services communicate their health back to the service discovery agent\n\n## Spring Cloud LoadBalancer and Resilience4j\n\n#### Resilience4j - It is a fault tolerance library which offers the following patterns for increasing fault tolerance due to network problems or failure of any of our multiple services\n\n- Circuit breaker - Stops making requests when an invoked service is failing\n\n- Retry - Retries service when it temporarily fails\n\n- Bulkhead - Limits the number of outgoing concurrent service requests to avoid overload\n\n- Rate limit - Limits the number of calls that a service receives at a time\n\n- Fallback - Sets alternative paths for failing requests\n\n## Spring Cloud Gateway\n\n#### Mapping the routes for all the services in your application to a single URL\n\n#### Building filters that can inspect and act on the requests and responses coming through the gateway\n\n#### Building prediccates, which are objects that allow us to check if the requests fulfill a set of given conditions before executing or processing a requests\n\n#### It is a reverse proxy. A reverse proxy is an intermediate server that sits between the client trying to reach a resource and the resource itself. The client has no idea it's even communicating with a server. The reverse proxy takes care of capturing the client's request andthen calls the remote resource on the client's behalf.\n"},"content":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    h1: \"h1\",\n    h2: \"h2\",\n    h4: \"h4\",\n    ul: \"ul\",\n    li: \"li\",\n    p: \"p\"\n  }, _provideComponents(), props.components);\n  return _jsxs(_Fragment, {\n    children: [_jsx(_components.h1, {\n      children: \"Spring Cloud\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Spring Cloud Config\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"It handles the management of the application configuration data through a centralized service\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"This ensures that no matter how many microservice instances you bring up, they will always have the same configuration.\"\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Spring Cloud Service Discovery\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"You can abstract away the physical location (IP and/or server name) of where your servers are deployed from the clients consuming the service.\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"It also handles the registration and deregistration of service instances as these are started and shut down.\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Service Registration - How a service registers with the service discovery agent\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Client lookup of service address - How a service client looks up service information\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Information sharing - How nodes share service information\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Health monitoring - How services communicate their health back to the service discovery agent\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Spring Cloud LoadBalancer and Resilience4j\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Resilience4j - It is a fault tolerance library which offers the following patterns for increasing fault tolerance due to network problems or failure of any of our multiple services\"\n    }), \"\\n\", _jsxs(_components.ul, {\n      children: [\"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Circuit breaker - Stops making requests when an invoked service is failing\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Retry - Retries service when it temporarily fails\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Bulkhead - Limits the number of outgoing concurrent service requests to avoid overload\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Rate limit - Limits the number of calls that a service receives at a time\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.li, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Fallback - Sets alternative paths for failing requests\"\n        }), \"\\n\"]\n      }), \"\\n\"]\n    }), \"\\n\", _jsx(_components.h2, {\n      children: \"Spring Cloud Gateway\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Mapping the routes for all the services in your application to a single URL\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Building filters that can inspect and act on the requests and responses coming through the gateway\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"Building prediccates, which are objects that allow us to check if the requests fulfill a set of given conditions before executing or processing a requests\"\n    }), \"\\n\", _jsx(_components.h4, {\n      children: \"It is a reverse proxy. A reverse proxy is an intermediate server that sits between the client trying to reach a resource and the resource itself. The client has no idea it's even communicating with a server. The reverse proxy takes care of capturing the client's request andthen calls the remote resource on the client's behalf.\"\n    })]\n  });\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, props)\n  })) : _createMdxContent(props);\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true}